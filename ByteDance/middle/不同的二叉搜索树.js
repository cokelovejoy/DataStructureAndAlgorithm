// 不同的二叉搜索树
// 给定一个整数n,求恰由n个节点组成且节点值从1到n互不相同的二叉搜索树有多少种.
// 动态规划法
// dp数组及下标含义
// dp状态初始化
// 状态转移方程 dp[i] += dp[j-1] * dp[i-j]
// dp[3] 就是元素1为头节点搜索树的数量+元素2为头节点搜索树的数量+元素3为头节点搜索树的数量
// 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
// 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
// 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
// 有2个元素的搜索树数量就是dp[2]。
// 有1个元素的搜索树数量就是dp[1]。
// 有0个元素的搜索树数量就是dp[0]。
// 所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

function numTrees(n) {
  let dp = Array(n + 1).fill(0);
  dp[0] = 1; // 状态初始化
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }
  return dp[n];
}
console.log(numTrees(3));
