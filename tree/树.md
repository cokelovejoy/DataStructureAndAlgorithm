# 树

## 完全二叉树

在二叉树的基础上，从上至下、从左至右没有空结点。

## 满二叉树

完全二叉树 的最后一层没有空结点，此时完全二叉树称为 满二叉树。
满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。

## 使用数组表示完全二叉树

按照从上至下、从左至右的顺序给完全二叉树编号，任意结点的父亲结点和子结点的下标是有规律的。

```js
parentIndex = (i - 1) / 2; // 当前结点的父节点下标
leftChildIndex = 2 * i + 1; // 左孩子结点下标
rightChildIndex = 2 * i + 2; // 右孩子结点下标
```

## 堆

优先队列的高效实现是堆，堆是一个完全二叉树，因此 可以存储在数组里，并且父亲结点和孩子结点可以很方便地互相访问。

### 大顶堆

任一结点的数值都大于等于它的两个孩子结点，树根结点这个元素一定是这棵二叉树中值最大的结点 。

### 小顶堆

任一结点的数值都小于等于它的两个孩子结点，树根节点这个元素一定是这棵二叉树中值最小的结点。

## 树的遍历

树的遍历有 深度优先遍历 （Depth First Search）和 广度优先遍历（Breadth First Search），其中深度优先遍历又分为前序遍历、中序遍历、后序遍历。

# 深度优先遍历

深度优先遍历是一个比较激进的方案，前方有路就一直向前走，不走近「死胡同」里，就不会回头。我们常说的「不撞南墙不回头」就是深度优先遍历的思想。

对于深度优先遍历而言，后遍历到的结点先输出，符合 后进先出 的规律，因此可以借助「栈」实现。

统一的逻辑是：首先将根结点入 栈，然后将结点出栈，每一个出栈结点做如下操作：

- 如果出栈结点有右结点，把右结点加入栈顶；
- 如果出栈结点有左结点，把左结点加入栈顶；
- 直到没有结点可以入栈，依次将结点从栈顶出栈，每次出栈遵守上面的规则，只要有孩子结点，就依次入栈。出栈结点的顺序是深度优先遍历的顺序。
- 由于我们人为规定先遍历左子树的所有结点，再遍历右子树的所有结点。因此左、右结点的入栈顺序是：先右结点再左结点。

三种深度优先遍历的顺序，左子树一定在右子树的前面，区别在于根结点什么时候遍历。

### 前序遍历

前序遍历，对于每一棵树来说，总是先访问根结点，然后访问左子树，最后访问右子树。

### 中序遍历

中序遍历，对于每一棵树来说，总是先访问左子树，然后访问根结点，最后访问右子树。将二叉树的结点按照垂直方向上只有 1 个结点的要求摆放，用一条扫描线 从左到右 扫描二叉树，依次经过的结点，就是中序遍历序列。

### 后序遍历
后序遍历，对于每一棵树来说，总是先访问左子树，然后访问右子树，最后访问根结点
。
后序遍历是非常重要的解决二叉树问题的思想：需要把左右子树都遍历完成以后，才遍历当前结点的信息，所以后序遍历像是 一层一层向上传递信息。

后序遍历需要先读取左右子树的信息，然后再处理自己的逻辑，这也是典型的分而治之思想的体现：

- 递归处理左子树、右子树的信息 - 分
- 然后根据上一步的结果，处理当前结点的信息 - 治。


# 广度优先遍历

从根结点向下逐层进行遍历，并且同一层结点的遍历顺序为从左到右。因此，在树形结构中，广度优先遍历也叫 层序遍历。

对于广度优先遍历而言，先遍历到的结点先输出，符合 先进先出 的规律，因此可以借助「队列」实现。

统一的逻辑是：首先将根结点加入 队列，然后将结点出队尾，每一个出队结点做如下操作：

- 如果出队结点有左结点，把左结点加入队尾；
- 如果出队结点有右结点，把右结点加入队尾；
- 直到没有结点可入队，依次将结点从队首出队，每次出队遵守上面的规则，只要有孩子结点，就依次入队。出队结点的顺序是广度优先遍历的顺序。

# 深度优先遍历和广度优先遍历的比较

- 深度优先遍历和广度优先遍历都需要借助相应的数据结构，对即将访问到的元素在适当的时机 缓存 ：深度优先遍历使用的是栈，广度优先遍历使用的是队列；
- 遍历可以用于搜索，找到 所有 需要的元素；
- 深度优先遍历由于其本身的特性，在面对巨大的结果集的时候，能够使用较少的性能消耗，它的另一个名字叫 回溯算法 ，我们会在下一章节向大家介绍；
- 基于「两点之间，线段最短」，广度优先遍历可以用于搜索无向图的最短路径，这一点是非常关键的。
