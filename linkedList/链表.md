# 数据存储的两种基本数据结构
数组和链表
# 数组
数组，数据连续存储在内存中，特点：有利于访问数据(时间复杂度为 O(1))，不利于增删数据(时间复杂度为 O(N))。

# 链表
链表，数据分散存储在内存中，特点：有利于增删数据(时间复杂度为 O(1))，不利于访问数据(时间复杂度为 O(N))。

链表：每个结点由数据域和指针域组成，因此会占用更多的内存。
## 单链表
单向链表只能从第一个结点开始按照顺序单向访问链表中的结点，每一个结点只能访问到它的后继结点。
## 双向链表
双向链表的结点都有两指针域，分别指向前驱结点和后继结点。第一个结点没有前驱结点，最后一个结点没有后继结点。
## 循环链表
单向链表的最后一个结点指向单向链表的第一个结点，就形成了一个环形结构，这样的链表就称为循环单向链表。

双向链表的第一个结点的前驱结点指向链表的最后一个结点，最后一个结点后继结点指向链表的第一个结点，也形成了一个环形结构，这样的链表就称为循环双向链表。

# 链表处理技巧
## 虚拟头结点
在链表的实现中，一般也会设置虚拟头结点，处理链表起始结点的边界问题，它只起到占位和回避边界条件讨论的作用。

## 快慢指针 
快慢指针是指在链表遍历的过程中，使用两个指针变量 同向移动 的一种解决问题的技巧。

快慢指针的另一个经典应用是找链表的中点。此时使用快慢指针，有一点技巧：

1. 快慢指针一开始是同起跑线的；
2. 然后快指针一次走 2 步，慢指针一次走 1 步，一旦快指针走到了末尾，慢指针就正好来到了链表的中间

# 链表经典问题
## 环形链表
判断链表是否为环形链表
## 相交链表
相交链表，就是这两个链表是有公共部分，要求我们返回这个公共部分的第一个结点。

# 栈
栈是一种后进先出的数据结构，要求只能在栈顶进行插入和删除操作。

数组实现栈，栈顶要设置在数组的末尾。
单链表实现栈，栈顶要设置在单链表的头部。

使用场景： 递归，后面的函数先执行。深度优先遍历，借助递归实现。括号匹配，算术表达式，撤销回退等都使用到了栈。
## 栈的数组实现
## 栈的链表实现

# 队列
队列是一种先进先出的数据结构，要求在队头删除，在队尾插入数据。

同样队列也可以使用数组或链表实现。

使用场景：任务队列，消息队列，广度优先遍历使用了队列。
## 队列的数组实现
## 队列的链表实现
## 栈实现队列
## 队列实现栈
## 双端队列（Deque）
## 优先队列
优先队列在元素 出队 的时候做了特殊的规定：按照元素的 优先级顺序 出队。优先队列可以帮助我们在一系列 动态 发生的任务列表中，高效地寻找优先级最高的任务。

# 树
## 完全二叉树
在二叉树的基础上，从上至下、从左至右没有空结点。
## 满二叉树
完全二叉树 的最后一层没有空结点，此时完全二叉树称为 满二叉树。
满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。
## 使用数组表示完全二叉树
按照从上至下、从左至右的顺序给完全二叉树编号，任意结点的父亲结点和子结点的下标是有规律的。
```js
parentIndex = (i - 1) / 2; // 当前结点的父节点下标
leftChildIndex = 2 * i + 1; // 左孩子结点下标
rightChildIndex = 2 * i + 2;// 右孩子结点下标
```
## 堆
优先队列的高效实现是堆，堆是一个完全二叉树，因此 可以存储在数组里，并且父亲结点和孩子结点可以很方便地互相访问。
### 大顶堆
任一结点的数值都大于等于它的两个孩子结点，树根结点这个元素一定是这棵二叉树中值最大的结点 。
### 小顶堆
任一结点的数值都小于等于它的两个孩子结点，树根节点这个元素一定是这棵二叉树中值最小的结点。